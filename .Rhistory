colorColumnNames  #mesquite.charMatrices.CharGroupColor.CharGroupColor;
colorText  #mesquite.charMatrices.NoColor.NoColor;
setBackground White;
toggleShowNames on;
toggleShowTaxonNames on;
toggleTight off;
toggleThinRows off;
toggleShowChanges on;
toggleSeparateLines off;
toggleShowStates on;
toggleAutoWCharNames on;
toggleAutoTaxonNames off;
toggleShowDefaultCharNames off;
toggleConstrainCW on;
toggleBirdsEye off;
toggleShowPaleGrid off;
toggleShowPaleCellColors off;
toggleShowPaleExcluded off;
togglePaleInapplicable on;
toggleShowBoldCellText off;
toggleAllowAutosize on;
toggleColorsPanel off;
toggleLinkedScrolling on;
toggleScrollLinkedTables off;
endTell;
showWindow;
getWindow;
tell It;
forceAutosize;
endTell;
getEmployee #mesquite.charMatrices.AlterData.AlterData;
tell It;
toggleBySubmenus off;
endTell;
getEmployee #mesquite.charMatrices.ColorByState.ColorByState;
tell It;
setStateLimit 9;
toggleUniformMaximum on;
endTell;
getEmployee #mesquite.charMatrices.ColorCells.ColorCells;
tell It;
setColor Red;
removeColor off;
endTell;
getEmployee #mesquite.charMatrices.AnnotPanel.AnnotPanel;
tell It;
togglePanel off;
endTell;
getEmployee #mesquite.charMatrices.CharReferenceStrip.CharReferenceStrip;
tell It;
showStrip off;
endTell;
getEmployee #mesquite.charMatrices.SelSummaryStrip.SelSummaryStrip;
tell It;
showStrip off;
endTell;
getEmployee #mesquite.cont.ItemsEditorForInfoPanel.ItemsEditorForInfoPanel;
tell It;
panelOpen false;
endTell;
endTell;
endTell;
getEmployee  #mesquite.charMatrices.ManageCharacters.ManageCharacters;
tell It;
showCharacters #2333225643795040419 #mesquite.lists.CharacterList.CharacterList;
tell It;
setData 0;
getWindow;
tell It;
useTargetValue off;
setTargetValue ;
newAssistant  #mesquite.lists.DefaultCharOrder.DefaultCharOrder;
newAssistant  #mesquite.lists.CharListInclusion.CharListInclusion;
newAssistant  #mesquite.lists.CharListPartition.CharListPartition;
newAssistant  #mesquite.parsimony.CharListParsModels.CharListParsModels;
setExplanationSize 30;
setAnnotationSize 20;
setFontIncAnnot 0;
setFontIncExp 0;
setSize 1820 884;
setLocation -9 -9;
setFont SanSerif;
setFontSize 10;
getToolPalette;
tell It;
endTell;
endTell;
showWindow;
getEmployee #mesquite.lists.CharListAnnotPanel.CharListAnnotPanel;
tell It;
togglePanel off;
endTell;
endTell;
endTell;
endTell;
end;
install.packages(c("dplyr", "vioplot"))
library(MASS)
library(lattice)
library(vioplot)
library(dplyr)
library(ggplot2)
library(dplyr)
source('C:/Users/13215/Downloads/Class1script_2019.R', echo=TRUE)
library(MASS)
library(lattice)
library(lattice)
library(vioplot)
library(dplyr)
library(ggplot2)
library(dplyr)
# If you need to use an R library or package and don't already have it, you can tell R to download and install it. For example:
# install.packages("vioplot")
install.packages("vioplot")
# If you need to use an R library or package and don't already have it, you can tell R to download and install it. For example:
# install.packages("vioplot")
install.packages("vioplot")
protea_survival.txt
setwd(protea_survival.txt)
# Check the data set is loaded and looks OK
head(Sitka)
class(Sitka) # tells you what kind of object this is. In this case, we want it to be a data frame (or a "tibble," which is a form of data frame)
str(Sitka) # more info about the object, including about the different columns it includes, and the types of date in each column.
# First it's useful to look at the overall distribution of the data.
# That's good to know and also helps check for data entry errors.
hist(Sitka$size)
stem(Sitka$size)
# For example, what if someone typed "61.5" instead of "6.15"?
# Insert the error into the data set:
Sitka$size[which(Sitka$size==6.15)] <- 61.5
stem(Sitka$size)
# Now it's easy to see it if we just look:
stem(Sitka$size)
# Now it's easy to see it if we just look:
stem(Sitka$size)
# And if we're sure it's a typo we could fix it, or we could set the observation to NA (no data).
Sitka$size[which(Sitka$size==61.5)] <- 6.15 # <- NA
stem(Sitka$size)
# Make quantile plots of the response variable. A normal quantile plot visually compares the distribution of some data to a normal distribution.
qqnorm(Sitka$size, main="Normal Q-Q plot", xlab="Theoretical quantiles", ylab="Sample quantiles", )
# For example if the plot looked like this?
Sitka_size_skewed <- c(Sitka$size, rnorm(10, mean=8, sd=1))
qqnorm(Sitka_size_skewed, main="Normal Q-Q plot", xlab="Theoretical quantiles", ylab="Sample quantiles")
# Hint: hist(Sitka_size_skewed)
hist(Sitka_size_skewed)
# First it's useful to look at the overall distribution of the data.
# That's good to know and also helps check for data entry errors.
hist(Sitka$size)
qqnorm(Sitka_size_skewed, main="Normal Q-Q plot", xlab="Theoretical quantiles", ylab="Sample quantiles")
# Make quantile plots of the response variable. A normal quantile plot visually compares the distribution of some data to a normal distribution.
qqnorm(Sitka$size, main="Normal Q-Q plot", xlab="Theoretical quantiles", ylab="Sample quantiles", )
qqnorm(Sitka_size_skewed, main="Normal Q-Q plot", xlab="Theoretical quantiles", ylab="Sample quantiles")
# Hint: hist(Sitka_size_skewed)
hist(Sitka_size_skewed)
# We are often interested in what the data look like in different experimental treatments. To do this, we can subset the data by treatment level and look at those subgroups. Here treatment is in the column "treat" and has two levels, which we can identify this way:
levels(Sitka$treat)
x1 <- filter(Sitka, treat=="control")
# We are often interested in what the data look like in different experimental treatments. To do this, we can subset the data by treatment level and look at those subgroups. Here treatment is in the column "treat" and has two levels, which we can identify this way:
levels(Sitka$treat)
x1 <- filter(Sitka, treat=="control")
# We are often interested in what the data look like in different experimental treatments. To do this, we can subset the data by treatment level and look at those subgroups. Here treatment is in the column "treat" and has two levels, which we can identify this way:
levels(Sitka$treat)
x1 <- filter(Sitka, treat=="control")
x1 <- filter(Sitka, Sitka$treat=="control")
# Note the function filter::dplyr is a cleaner way to select rows of a data frame than the more direct but clunky equivalent of selecting elements directly: Sitka[Sitka$treat=="control",]
x2 <- filter(Sitka, Sitka$treat=="ozone")
vioplot(x1$size, x2$size, names=c("control", "ozone"), col="lightgray")
require("vioplot")
vioplot(x1$size, x2$size, names=c("control", "ozone"), col="lightgray")
x1 <- filter(Sitka, treat=="control")
x1 <- filter(Sitka, treat = "control")
x1 <- filter(Sitka, treat == "control")
x1
x2
Sitka
View(Sitka)
x1 <- filter(Sitka, treat == "control")
require(dplyr0)
require("dplyr")
x1 <- filter(Sitka, treat == "control")
# Note the function filter::dplyr is a cleaner way to select rows of a data frame than the more direct but clunky equivalent of selecting elements directly: Sitka[Sitka$treat=="control",]
x2 <- filter(Sitka, treat=="ozone")
vioplot(x1$size, x2$size, names=c("control", "ozone"), col="lightgray")
# We can use the ability of ggplot to split the data into groups before plotting to make a similar plot:
ggplot(Sitka, aes(y=size, x=treat)) + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), aes(fill=treat))
library(ggplot2)
require("ggplot2")
# We can use the ability of ggplot to split the data into groups before plotting to make a similar plot:
ggplot(Sitka, aes(y=size, x=treat)) + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), aes(fill=treat))
ggplot(Sitka, aes(y=size, x=treat)) + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), aes(fill=treat))
# Boxplots are a simple and widely used kind of visual summary and can be used to compare data across groups:
boxplot(size~Time, Sitka, xlab="Time (days)")
# Q: What are the different parts of the boxplot displaying and how might those be useful?
#the upper and lower limit, the first quartile and third quartile, and the mean and outliers.
# Adding "notches" to a boxplot gives a rough visual way to see whether the means of the groups are significantly different:
boxplot(size~Time, Sitka, xlab="Time (days)", notch=T)
# Boxplots are a simple and widely used kind of visual summary and can be used to compare data across groups:
boxplot(size~Time, Sitka, xlab="Time (days)")
# We can also make boxplots using the formula interface
boxplot(size~treat, Sitka, ylab ="Size (m)", xlab="Treatment", notch=T, col="lightgreen")
boxplot(size~treat+Time,Sitka, col=c("lightblue", "pink"), ylab="Size (m)")
# A quick note on display -- here the axis labels won't fit, so you can rotate them if you want
boxplot(size~treat+Time,Sitka, col=c("lightblue", "pink"), ylab="Size (m)", las=2)
# Basic scatter plot
plot(size~Time, Sitka, xlab="Time (days)", ylab="Size (m)")
# For looking at continuous data against a factor or grouping variable, in addition to boxplots there are stripplots (also called dotplots):
stripplot(Time~size, data=Sitka, jitter.data=T, group=treat, aspect=1, xlab="Size (m)")
library(MASS)
install.package("MASS")
install.packages("MASS")
lambda1 <- 0.1
lambda2 <- 0.25
lambda3 <- 0.5
lambda4 <- 1
lambda5 <- 2
lambda6 <- 4
lambda7 <- 10
for (i in 1:10000) {
x1[i] <- dnExponential(lambda1)
x2[i] <- dnExponential(lambda2)
x3[i] <- dnExponential(lambda3)
x4[i] <- dnExponential(lambda4)
x5[i] <- dnExponential(lambda5)
x6[i] <- dnExponential(lambda6)
x7[i] <- dnExponential(lambda7)
}
mean(x1)
mean(x2)
mean(x3)
mean(x4)
mean(x5)
mean(x6)
mean(x7)
for (i in 1:10000) {
x1[i] <- dnExponential(lambda1)
x2[i] <- dnExponential(lambda2)
x3[i] <- dnExponential(lambda3)
x4[i] <- dnExponential(lambda4)
x5[i] <- dnExponential(lambda5)
x6[i] <- dnExponential(lambda6)
x7[i] <- dnExponential(lambda7)
}
for (i in 1:10000) {
x1[i] <- rexp(lambda1)
x2[i] <- rexp(lambda2)
x3[i] <- rexp(lambda3)
x4[i] <- rexp(lambda4)
x5[i] <- rexp(lambda5)
x6[i] <- rexp(lambda6)
x7[i] <- rexp(lambda7)
}
x1 <- c()
x1 <- c()
x2 <- c()
x3 <- c()
x4 <- c()
x5 <- c()
x6 <- c()
x7 <- c()
for (i in 1:10000) {
x1[i] <- rexp(lambda1)
x2[i] <- rexp(lambda2)
x3[i] <- rexp(lambda3)
x4[i] <- rexp(lambda4)
x5[i] <- rexp(lambda5)
x6[i] <- rexp(lambda6)
x7[i] <- rexp(lambda7)
}
lambda1 <- 0.1
lambda2 <- 0.25
lambda3 <- 0.5
lambda4 <- 1
lambda5 <- 2
lambda6 <- 4
lambda7 <- 10
for (i in 1:10000) {
x1[i] <- rexp(lambda1)
x2[i] <- rexp(lambda2)
x3[i] <- rexp(lambda3)
x4[i] <- rexp(lambda4)
x5[i] <- rexp(lambda5)
x6[i] <- rexp(lambda6)
x7[i] <- rexp(lambda7)
}
mean(x1)
mean(x2)
mean(x3)
mean(x4)
mean(x5)
mean(x6)
mean(x7)
install.packages("rmarkdown")
A=rbind(c(-0.7749,0.2251,0.2251,0.2251),c(0.2648,-0.7352,0.2648,0.2648),c(0.3188,0.3188,-0.6812,0.3188),c(0.1913,0.1913,0.1913,-0.8087))
A=rbind(c(-0.7749,0.2251,0.2251,0.2251),c(0.2648,-0.7352,0.2648,0.2648),c(0.3188,0.3188,-0.6812,0.3188),c(0.1913,0.1913,0.1913,-0.8087))
View(A)
estuff=eigen(A)
lambda=estuff$values
w=estuff$vectors
w[,3]
w[,4]
lambda
x0=c(0.25,0.25,0.25,0.25)
c=solve(w,x0)
c
x=function(t)c[1]*exp(lambda[1]*t)*w[,1]+c[2]*exp(lambda[2]*t)*w[,2]+c[3]*exp(lambda[3]*t)*w[,3]+c[4]*exp(lambda[4]*t)*w[,4]
x(0)
x0=c(0.25,0.25,0.25,0.192)
c=solve(w,x0)
c
x=function(t)c[1]*exp(lambda[1]*t)*w[,1]+c[2]*exp(lambda[2]*t)*w[,2]+c[3]*exp(lambda[3]*t)*w[,3]+c[4]*exp(lambda[4]*t)*w[,4]
x(0)
t
c
x(0)
x
x0=c(0.25,0.25,0.25,0.25)
c=solve(w,x0)
c
x=function(t)c[1]*exp(lambda[1]*t)*w[,1]+c[2]*exp(lambda[2]*t)*w[,2]+c[3]*exp(lambda[3]*t)*w[,3]+c[4]*exp(lambda[4]*t)*w[,4]
x(0)
x(1)
x(2)
x(2.1)
x(2.4)
x(3)
x(3.5)
x(3.7)
x(3.8)
(4.2)
x(4.2)
x(4.3)
x(4.4)
View(estuff)
P=cbind(c(0.91,0.01,0.08),c(0.57,0.16,0.27),c(0.4,0.07,0.53))
colSums(P)
pi=c(1,0,0) # i.e. dry day with probability one
for(t in 1:10)pi=P%*%pi
print(pi)
P=cbind(c(0.84,0.03,0.01,0.03,0.03),c(0.11,0.80,0.15,0.19,0.09),c(0.01,0.04,0.70,0.02,0.05),c(0.01,0.04,0.07,0.75,0),c(0,0.03,0.07,0.01,0.83))
colSums(P)
pi=c(1,0,0,0,0) # i.e. dry day with probability one
for(t in 1:5)pi=P%*%pi
print(pi)
P=cbind(c(1,.51,0,0,0,0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0),c(0,0,.49,0,0.51,0),c(0,0,0,0.49,0, .51), c(0,0,0,0,.49,0))
P=cbind(c(1,.51,0,0,0,0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0,0),c(0,0,.49,0,0.51,0),c(0,0,0,0.49,0, .51), c(0,0,0,0,.49,0))
colSums(P)
P=cbind(c(1,.51,0,0,0,0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0,0),c(0,0,.49,0,0.51,0),c(0,0,0,0.49,0, .51), c(0,0,0,0,.49,0))
View(P)
P=cbind(c(1,.51,0,0,0,0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0,0),c(0,0,.49,0,0.51,0),c(0,0,0,0.49,0, .51), c(0,0,0,0,.49,0))
colSums(P)
P=cbind(c(1,0,0,0,0,0),c(0.51,0,0.49,0,0,0),c(0,0.51,0,0.49,0,0),c(0,0,.51,0,0.49,0),c(0,0,0,0.51,0, .49), c(0,0,0,0,.51,.49))
colSums(P)
pi=c(0,0,1,0,0,0) # i.e. dry day with probability one
for(t in 1:2)pi=P%*%pi
print(pi)
for(t in 1:3)pi=P%*%pi
print(pi)
for(t in 1:4)pi=P%*%pi
print(pi)
for(t in 1:5)pi=P%*%pi
print(pi)
for(t in 1:50)pi=P%*%pi
print(pi)
P=cbind (c(0.84, 0.11,0.01, 0.04, 0.00), c(0.03, 0.8, 0.04, 0.1, 0.03),c(0.01, 0.15, 0.7, 0.07, 0.07),c(0.03, 0.19, 0.02, 0.75, 0.01), c(0.03, 0.09, 0.05, 0.00, 0.83))
colSums(P)
pi=c(1,0,0,0,0) # i.e. dry day with probability one
for(t in 1:5)pi=P%*%pi
print(pi)
for(t in 1:1000)pi=P%*%pi
print(pi)
P=cbind (c(.25,.25,.25,.25), c(0.25,0.25,0.25,0.25), c(0.25,0.25,0.25,0.25), c(0.25,0.25,0.25,0.25))
P=cbind (c(0.91, 0.01, 0.08), c(0.57, 0.16, 0.27), c(0.4, 0.07, 0.53))
colSums(P)
for(t in 1:10)pi=P%*%pi
print(pi)
P=cbind (c(0.91, 0.01, 0.08), c(0.57, 0.16, 0.27), c(0.4, 0.07, 0.53))
colSums(P)
pi=c() # i.e. dry day with probability one
for(t in 1:10)pi=P%*%pi
print(pi)
P=cbind (c(0.91, 0.01, 0.08), c(0.57, 0.16, 0.27), c(0.4, 0.07, 0.53))
colSums(P)
pi=c() # i.e. dry day with probability one
pi=c(1,0,0) # i.e. dry day with probability one
pi=c(1,0,0) # i.e. dry day with probability one
for(t in 1:10)pi=P%*%pi
print(pi)
for(t in 1:10000)pi=P%*%pi
print(pi)
for(t in 1:20000)pi=P%*%pi
print(pi)
for(t in 1:10)pi=P%*%pi
print(pi)
pi=c(0,0,1) # i.e. dry day with probability one
print(pi)
for(t in 1:10)pi=P%*%pi
print(pi)
P=cbind(c(1, 0.51, 0, 0, 0, 0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0,0),c(0,0,0.49,0,0.51,0),c(0,0,0,0.49,0,0),c(0,0,0,0,0.49,1))
colSums(P)
pi=c(0,0,1,0,0,0)
colSums(P)
rowSums(P)
pi=c(0,0,1,0,0,0)
View(P)
P=rbind(c(1, 0.51, 0, 0, 0, 0),c(0,0,0.51,0,0,0),c(0,0.49,0,0.51,0,0),c(0,0,0.49,0,0.51,0),c(0,0,0,0.49,0,0),c(0,0,0,0,0.49,1))
colSums(P)
pi=c(0,0,1,0,0,0)
for(t in 1:3)pi=P%*%pi
print(pi)
for(t in 1:4)pi=P%*%pi
print(pi)
for(t in 1:5)pi=P%*%pi
print(pi)
for(t in 1:10000000000000000)pi=P%*%pi
for(t in 1:100000)pi=P%*%pi
print(pi)
sj=c(0.56, 0.64, 0.3, 0.4, 0, 0.38, 0.18, 0.25, 0.44)
sa=c(0.53, 0.68, 0.71, 0.38, 0.54, 0.69, 0.66, 0.49, 0.61)
f=c(3.38, 1.27, 2.77, 2.17, 0.05, 4.0, 2.37, 0.5, 1.6)
W=sj*f/2+sa
W=sj*f/2+sa
w
W
low_w=log(w)
low_w=ln(w)
ln(w)
log(W)
mean(log(W))
A=rbind(c(.02, 2, 80),
c(.18, .63, 0),
c(0, 0.07, 0))
View(A)
estuff=eigen(A)
estuff
lambda=estuff$values
lambda
w=estuff$vectors
w
View(estuff)
x0=c(1000, 0, 0)
c=solve(w,x0)
c
x=function(t)c[1]*exp(lambda[1]*t)*w[,1]+c[2]*exp(lambda[2]*t)*w[,2]+c[3]*exp(lambda[3]*t)*w[,3]
x(10)
x(0)
x0=c(1000,0,0)
c=solve(w,x0)
c
x=function(t)c[1]*exp(lambda[1]*t)*w[,1]+c[2]*exp(lambda[2]*t)*w[,2]+c[3]*exp(lambda[3]*t)*w[,3]
x(10)
1-pnorm(1, mean = 0, sd=sqrt(2))
w2= rbind(c(0.95 0 0 0.1),
c(0.05 0 0 0),
c(0 1 0 0)
c(0 0 1 0.9))
w2= rbind(c(0.95 0 0 0.1),
c(0.05 0 0 0),
c(0 1 0 0),
c(0 0 1 0.9))
w2= rbind(c(0.95,0,0,0.1),
c(0.05,0,0,0),
c(0,1,0,0),
c(0,0,1,0.9))
P= rbind(c(0.95,0,0,0.1),
c(0.05,0,0,0),
c(0,1,0,0),
c(0,0,1,0.9))
P= rbind(c(0.95,0,0,0.1),
c(0.05,0,0,0),
c(0,1,0,0),
c(0,0,1,0.9))
estuff=eigen(P)
estuff
lambda=estuff$values
lambda
w=estuff$vectors
w
T=rep(1,5)
T%*%solve(diag(8)-A)
T%*%solve(diag(8)-P)
w
P
library(dplyr)
library(lubridate)
library(tidyverse)
library(ggrepel)
d = read_csv("allclimdata.csv") %>%
rename(pop = ID1) %>%
rename(site = ID2) %>%
rename(lat = Latitude) %>%
rename(long = Longitude) %>%
rename(el = Elevation) %>%
mutate(herbivory =
ifelse(pop %in% c("LV1", "TM2", "CP2", "YOSE11", "BH", "SHA", "WL2", "YOSE1", "SQ3", "KC2"), "x", NA)
) %>%
filter(herbivory == "x") %>%
#filter(year < 2019) %>%
select(year, pop, el, lat, long, site, "CMD_sm", "PPT_sm", "DD5_sm") %>%
gather(key="var", value="value", "CMD_sm", "PPT_sm", "DD5_sm")
clams <- read.table("Datasets/Clams.txt")
clams <- read.table("Datasets\Clams.txt")
clams <- read.table("Clams.txt")
clams <- read.table("~/Datasets/Clams.txt")
clams <- read.table("~Datasets/Clams.txt")
clams <- read.table("Github/Datasets/Clams.txt")
clams <- read.table(~/Github/Datasets/Clams.txt")
clams <- read.table("~/Github/Datasets/Clams.txt")
clams <- read.table("~/Github/Datasets/Clams.txt")
clams <- read.table("Datasets/Clams.txt")
setwd("~/GitHub/linear-mized-modeling-eve298")
setwd("~/GitHub/linear-mized-modeling-eve298")
clams <- read.table("Datasets/Clams.txt")
